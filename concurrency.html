<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Distributed DB Concurrency Demo</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        background: #111;
        color: #eee;
        padding: 16px;
      }
      h2,
      h3 {
        margin-bottom: 4px;
      }
      label {
        display: inline-block;
        width: 120px;
      }
      .row {
        margin: 4px 0;
      }
      fieldset {
        margin-top: 16px;
        padding: 10px 12px;
        border: 1px solid #444;
        border-radius: 4px;
      }
      legend {
        padding: 0 4px;
        font-weight: bold;
      }
      button {
        margin: 2px 4px 2px 0;
        padding: 6px 10px;
        border-radius: 4px;
        border: 1px solid #555;
        background: #222;
        color: #eee;
        cursor: pointer;
      }
      button:hover {
        background: #333;
      }
      textarea {
        width: 100%;
        min-height: 120px;
        font-family: monospace;
        font-size: 12px;
        background: #000;
        color: #0f0;
        padding: 6px;
        border-radius: 4px;
        border: 1px solid #444;
      }
      #log {
        background: #000;
        color: #0f0;
        padding: 8px;
        min-height: 250px;
        white-space: pre-wrap;
        font-family: monospace;
        font-size: 12px;
        border-radius: 4px;
      }
      .log-header {
        color: #0af;
      }
      .log-node-central {
        color: #0ff;
      }
      .log-node-node2 {
        color: #ff0;
      }
      .log-node-node3 {
        color: #f0f;
      }
    </style>
  </head>
  <body>
    <h2>Distributed DB Concurrency Demo</h2>

    <fieldset>
      <legend>Global Inputs</legend>
      <div class="row">
        <label for="userId">User ID:</label>
        <input id="userId" type="number" value="42" />
      </div>

      <div class="row">
        <label for="isolation">Isolation level:</label>
        <select id="isolation">
          <option value="READ UNCOMMITTED">READ UNCOMMITTED</option>
          <option value="READ COMMITTED" selected>READ COMMITTED</option>
          <option value="REPEATABLE READ">REPEATABLE READ</option>
          <option value="SERIALIZABLE">SERIALIZABLE</option>
        </select>
      </div>
      <div class="row">
        <button onclick="clearLog()">Clear log</button>
        <button onclick="runRecoveryAll()">Run recovery on all nodes</button>
      </div>
    </fieldset>

    <fieldset>
      <legend>Insert / Update Fields</legend>
      <div class="row">
        <label for="username">username:</label>
        <input id="username" type="text" />
      </div>
      <div class="row">
        <label for="first_name">first_name:</label>
        <input id="first_name" type="text" />
      </div>
      <div class="row">
        <label for="last_name">last_name:</label>
        <input id="last_name" type="text" />
      </div>
      <div class="row">
        <label for="city">city:</label>
        <input id="city" type="text" />
      </div>
      <div class="row">
        <label for="country">country:</label>
        <input id="country" type="text" />
      </div>
      <div class="row">
        <label for="zipcode">zipcode:</label>
        <input id="zipcode" type="text" />
      </div>
      <div class="row">
        <label for="gender">gender:</label>
        <input id="gender" type="text" />
      </div>
      <p style="font-size: 11px; opacity: 0.7">
        These fields are used for both simple inserts and scripted UPDATE/INSERT steps (if you don't override them in
        the script).
      </p>
    </fieldset>

    <fieldset>
      <legend>Simple Insert (auto-generated ID)</legend>
      <p style="font-size: 12px; opacity: 0.8">
        Calls <code>/txn/insert-auto</code> on the selected node. The backend generates a new primary key, inserts
        locally, then replicates according to your replication rules.
      </p>

      <div class="row">
        <strong>Central (node1)</strong>
      </div>
      <div class="row">
        <label>
          <input type="checkbox" id="centralInsertSimError" />
          Simulate replication error
        </label>
        <button onclick="insertOnNode('central')">Insert on central</button>
      </div>

      <div class="row" style="margin-top: 8px">
        <strong>Node2</strong>
      </div>
      <div class="row">
        <label>
          <input type="checkbox" id="node2InsertSimError" />
          Simulate replication error
        </label>
        <button onclick="insertOnNode('node2')">Insert on node2</button>
      </div>

      <div class="row" style="margin-top: 8px">
        <strong>Node3</strong>
      </div>
      <div class="row">
        <label>
          <input type="checkbox" id="node3InsertSimError" />
          Simulate replication error
        </label>
        <button onclick="insertOnNode('node3')">Insert on node3</button>
      </div>
    </fieldset>

    <fieldset>
      <legend>Custom Scripted Txn (using /txn/scripted)</legend>
      <p style="font-size: 12px; opacity: 0.8">
        Each script should be a JSON array of steps. Example:<br />
        <code>
          [ { "type": "READ" }, { "type": "SLEEP", "delayMs": 1000 }, { "type": "UPDATE", "data": { "city": "NewCity" }
          }, { "type": "READ" } ]
        </code>
      </p>

      <h4>Central node script (node1)</h4>
      <textarea id="script-central">
[
  { "type": "READ" },
  { "type": "SLEEP", "delayMs": 1000 },
  { "type": "UPDATE", "data": { "city": "CentralCity-" } },
  { "type": "READ" }
]</textarea
      >
      <div class="row">
        <label>
          <input type="checkbox" id="centralSimError" />
          Simulate replication error on central
        </label>
      </div>

      <h4>Node2 script</h4>
      <textarea id="script-node2">
[
  { "type": "READ" },
  { "type": "SLEEP", "delayMs": 500 },
  { "type": "UPDATE", "data": { "city": "Node2City-" } },
  { "type": "READ" }
]</textarea
      >
      <div class="row">
        <label>
          <input type="checkbox" id="node2SimError" />
          Simulate replication error on node2
        </label>
      </div>

      <h4>Node3 script (optional)</h4>
      <textarea id="script-node3">
[
  { "type": "READ" }
]</textarea
      >
      <div class="row">
        <label>
          <input type="checkbox" id="node3SimError" />
          Simulate replication error on node3
        </label>
      </div>

      <div style="margin-top: 8px">
        <button onclick="runScriptedAll()">Run scripted on all nodes</button>
      </div>
    </fieldset>

    <h3>Log</h3>
    <pre id="log"></pre>

    <script>
      // ðŸ”§ CONFIG: adjust these URLs to match your Docker/setup
      const NODES = {
        central: "http://localhost:3001", // central node (full copy, NODE_NAME = node1)
        node2: "http://localhost:3002", // fragment (NODE_NAME = node2)
        node3: "http://localhost:3003", // fragment (NODE_NAME = node3)
      };

      const logEl = document.getElementById("log");

      function clearLog() {
        logEl.textContent = "";
      }

      function pretty(obj) {
        if (typeof obj === "string") return obj;
        try {
          return JSON.stringify(obj, null, 2);
        } catch {
          return String(obj);
        }
      }

      function log(msg, cssClass) {
        const now = new Date().toISOString();
        const line = `[${now}] ${msg}\n`;
        logEl.textContent += line;
      }

      function getUpdateFields() {
        const readField = (id) => {
          const v = document.getElementById(id).value;
          return v === "" ? undefined : v;
        };

        return {
          username: readField("username"),
          first_name: readField("first_name"),
          last_name: readField("last_name"),
          city: readField("city"),
          country: readField("country"),
          zipcode: readField("zipcode"),
          gender: readField("gender"),
        };
      }

      function getIsolation() {
        return document.getElementById("isolation").value;
      }

      function getUserId() {
        return Number(document.getElementById("userId").value);
      }

      async function postJson(url, body) {
        const res = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });

        const text = await res.text().catch(() => "");
        let parsed;
        try {
          parsed = JSON.parse(text);
        } catch {
          parsed = text;
        }
        return { status: res.status, body: parsed };
      }

      function baseUrlForKey(nodeKey) {
        if (nodeKey === "central") return NODES.central;
        if (nodeKey === "node2") return NODES.node2;
        if (nodeKey === "node3") return NODES.node3;
        return null;
      }

      function baseUrlForNodeName(nodeName) {
        // nodeName is like "node1", "node2", "node3" from replicationDto
        if (nodeName === "node1") return NODES.central;
        if (nodeName === "node2") return NODES.node2;
        if (nodeName === "node3") return NODES.node3;
        return null;
      }

      // ðŸ” Run recovery on all nodes sequentially
      async function runRecoveryAll() {
        log("--- Running recovery on all nodes (central â†’ node2 â†’ node3) ---", "log-header");

        const nodes = [
          { key: "central", url: NODES.central },
          { key: "node2", url: NODES.node2 },
          { key: "node3", url: NODES.node3 },
        ];

        for (const { key, url } of nodes) {
          log(`Calling ${key} /recovery/run`, "log-header");
          try {
            const res = await postJson(`${url}/recovery/run`, {});
            const cls = key === "central" ? "log-node-central" : key === "node2" ? "log-node-node2" : "log-node-node3";
            log(`${key} /recovery/run â†’ ${res.status}\n${pretty(res.body)}`, cls);
          } catch (e) {
            log(`${key} /recovery/run ERROR: ${e}`, "log-header");
          }
        }

        log("--- Recovery finished ---", "log-header");
      }

      // ====== INSERT FLOW: /txn/insert-auto â†’ /replication/apply â†’ /replication/mark-outgoing ======
      async function insertOnNode(nodeKey) {
        const isolation = getIsolation();
        const fields = getUpdateFields();
        const simCheckboxId = `${nodeKey}InsertSimError`;
        const simReplicationError = document.getElementById(simCheckboxId)?.checked || false;

        const sourceUrl = baseUrlForKey(nodeKey);
        if (!sourceUrl) {
          log(`Unknown source node key: ${nodeKey}`, "log-header");
          return;
        }

        const body = {
          isolation,
          simReplicationError,
          ...fields,
        };

        log(`${nodeKey} /txn/insert-auto â† ${pretty(body)}`, "log-header");

        const txRes = await postJson(`${sourceUrl}/txn/insert-auto`, body);

        const cls =
          nodeKey === "central" ? "log-node-central" : nodeKey === "node2" ? "log-node-node2" : "log-node-node3";

        log(`${nodeKey} /txn/insert-auto â†’ ${txRes.status}\n${pretty(txRes.body)}`, cls);

        const replicationDto = txRes.body?.replicationDto;
        if (!replicationDto) {
          log(`${nodeKey}: no replicationDto returned (no mutating op or no target node).`, "log-header");
          return;
        }

        const targetUrl = baseUrlForNodeName(replicationDto.targetNode);
        if (!targetUrl) {
          log(`Unknown target node in replicationDto: ${replicationDto.targetNode}`, "log-header");
          return;
        }

        // 2) apply on target
        log(
          `â†’ ${replicationDto.sourceNode} â†’ ${replicationDto.targetNode} /replication/apply â† ${pretty(
            replicationDto
          )}`,
          "log-header"
        );

        const applyRes = await postJson(`${targetUrl}/replication/apply`, replicationDto);
        log(`${replicationDto.targetNode} /replication/apply â†’ ${applyRes.status}\n${pretty(applyRes.body)}`, cls);

        // 3) mark outgoing on source
        const markBody = { globalTxId: replicationDto.globalTxId };
        const markRes = await postJson(`${sourceUrl}/replication/mark-outgoing`, markBody);
        log(
          `${replicationDto.sourceNode} /replication/mark-outgoing â†’ ${markRes.status}\n${pretty(markRes.body)}`,
          cls
        );
      }

      async function runScriptedChain(nodeKey, steps, simReplicationError) {
        const isolation = getIsolation();
        const userId = getUserId();
        const sourceUrl = baseUrlForKey(nodeKey);
        if (!sourceUrl) {
          log(`Unknown node key: ${nodeKey}`, "log-header");
          return;
        }

        const body = { isolation, userId, steps, simReplicationError };

        log(`${nodeKey} /txn/scripted â† ${pretty(body)}`, "log-header");

        const txRes = await postJson(`${sourceUrl}/txn/scripted`, body);

        const cls =
          nodeKey === "central" ? "log-node-central" : nodeKey === "node2" ? "log-node-node2" : "log-node-node3";

        log(`${nodeKey} /txn/scripted â†’ ${txRes.status}\n${pretty(txRes.body)}`, cls);

        const replicationDto = txRes.body?.replicationDto;
        if (!replicationDto) {
          log(`${nodeKey}: no replicationDto returned (no mutation or no target).`, "log-header");
          return;
        }

        const targetUrl = baseUrlForNodeName(replicationDto.targetNode);
        if (!targetUrl) {
          log(`Unknown target node in replicationDto: ${replicationDto.targetNode}`, "log-header");
          return;
        }

        // apply on target
        log(
          `â†’ ${replicationDto.sourceNode} â†’ ${replicationDto.targetNode} /replication/apply â† ${pretty(replicationDto)}`,
          "log-header"
        );

        const applyRes = await postJson(`${targetUrl}/replication/apply`, replicationDto);

        const targetCls =
          replicationDto.targetNode === "node1"
            ? "log-node-central"
            : replicationDto.targetNode === "node2"
              ? "log-node-node2"
              : "log-node-node3";

        log(
          `${replicationDto.targetNode} /replication/apply â†’ ${applyRes.status}\n${pretty(applyRes.body)}`,
          targetCls
        );

        // treat any 2xx apply as "success" for the log
        const success = applyRes.status >= 200 && applyRes.status < 300;

        if (success) {
          const markBody = { globalTxId: replicationDto.globalTxId, success: true };
          const markRes = await postJson(`${sourceUrl}/replication/mark-outgoing`, markBody);
          log(
            `${replicationDto.sourceNode} /replication/mark-outgoing â†’ ${markRes.status}\n${pretty(markRes.body)}`,
            cls
          );
        } else {
          log(
            `${replicationDto.sourceNode}: apply failed (status=${applyRes.status}), leaving PENDING for recovery.`,
            "log-header"
          );
        }
      }

      // âš™ï¸ Scripted runner: calls /txn/scripted + replication chain on any node that has a script
      async function runScriptedAll() {
        log("--- Custom SCRIPTED txns on central / node2 / node3 ---", "log-header");

        const scriptCentralText = document.getElementById("script-central").value.trim();
        const scriptNode2Text = document.getElementById("script-node2").value.trim();
        const scriptNode3Text = document.getElementById("script-node3").value.trim();

        const centralSimError = document.getElementById("centralSimError").checked;
        const node2SimError = document.getElementById("node2SimError").checked;
        const node3SimError = document.getElementById("node3SimError").checked;

        const tasks = [];

        const parseSteps = (txt, label) => {
          if (!txt) return null;
          try {
            const parsed = JSON.parse(txt);
            if (!Array.isArray(parsed)) {
              log(`${label}: script must be a JSON array of steps`, "log-header");
              return null;
            }
            return parsed;
          } catch (e) {
            log(`${label}: JSON parse error: ${e}`, "log-header");
            return null;
          }
        };

        const centralSteps = parseSteps(scriptCentralText, "central");
        const node2Steps = parseSteps(scriptNode2Text, "node2");
        const node3Steps = parseSteps(scriptNode3Text, "node3");

        if (centralSteps) {
          tasks.push(runScriptedChain("central", centralSteps, centralSimError));
        }
        if (node2Steps) {
          tasks.push(runScriptedChain("node2", node2Steps, node2SimError));
        }
        if (node3Steps) {
          tasks.push(runScriptedChain("node3", node3Steps, node3SimError));
        }

        if (tasks.length === 0) {
          log("No valid scripts to run.", "log-header");
          return;
        }

        await Promise.all(tasks);
        log("--- SCRIPTED run finished ---", "log-header");
      }
    </script>
  </body>
</html>
