<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Distributed DB Concurrency Demo</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        background: #111;
        color: #eee;
        padding: 16px;
      }
      h2,
      h3 {
        margin-bottom: 4px;
      }
      label {
        display: inline-block;
        width: 120px;
      }
      .row {
        margin: 4px 0;
      }
      fieldset {
        margin-top: 16px;
        padding: 10px 12px;
        border: 1px solid #444;
        border-radius: 4px;
      }
      legend {
        padding: 0 4px;
        font-weight: bold;
      }
      button {
        margin: 2px 4px 2px 0;
        padding: 6px 10px;
        border-radius: 4px;
        border: 1px solid #555;
        background: #222;
        color: #eee;
        cursor: pointer;
      }
      button:hover {
        background: #333;
      }
      textarea {
        width: 100%;
        min-height: 120px;
        font-family: monospace;
        font-size: 12px;
        background: #000;
        color: #0f0;
        padding: 6px;
        border-radius: 4px;
        border: 1px solid #444;
      }
      #log {
        background: #000;
        color: #0f0;
        padding: 8px;
        min-height: 250px;
        white-space: pre-wrap;
        font-family: monospace;
        font-size: 12px;
        border-radius: 4px;
      }
      .log-header {
        color: #0af;
      }
      .log-node-central {
        color: #0ff;
      }
      .log-node-node2 {
        color: #ff0;
      }
      .log-node-node3 {
        color: #f0f;
      }
    </style>
  </head>
  <body>
    <h2>Distributed DB Concurrency Demo</h2>

    <fieldset>
      <legend>Global Inputs</legend>
      <div class="row">
        <label for="userId">User ID:</label>
        <input id="userId" type="number" value="42" />
      </div>

      <div class="row">
        <label for="isolation">Isolation level:</label>
        <select id="isolation">
          <option value="READ UNCOMMITTED">READ UNCOMMITTED</option>
          <option value="READ COMMITTED" selected>READ COMMITTED</option>
          <option value="REPEATABLE READ">REPEATABLE READ</option>
          <option value="SERIALIZABLE">SERIALIZABLE</option>
        </select>
      </div>
      <div class="row">
        <button onclick="clearLog()">Clear log</button>
        <button onclick="runRecoveryAll()">Run recovery on all nodes</button>
      </div>
    </fieldset>

    <fieldset>
      <legend>Insert / Update Fields</legend>
      <div class="row">
        <label for="username">username:</label>
        <input id="username" type="text" />
      </div>
      <div class="row">
        <label for="first_name">first_name:</label>
        <input id="first_name" type="text" />
      </div>
      <div class="row">
        <label for="last_name">last_name:</label>
        <input id="last_name" type="text" />
      </div>
      <div class="row">
        <label for="city">city:</label>
        <input id="city" type="text" />
      </div>
      <div class="row">
        <label for="country">country:</label>
        <input id="country" type="text" />
      </div>
      <div class="row">
        <label for="zipcode">zipcode:</label>
        <input id="zipcode" type="text" />
      </div>
      <div class="row">
        <label for="gender">gender:</label>
        <input id="gender" type="text" />
      </div>
      <p style="font-size: 11px; opacity: 0.7">
        These fields are used for both simple inserts and scripted UPDATE/INSERT
        steps (if you don't override them in the script).
      </p>
    </fieldset>

    <fieldset>
      <legend>Simple Insert (auto-generated ID)</legend>
      <p style="font-size: 12px; opacity: 0.8">
        Calls <code>/txn/insert-auto</code> on the selected node. The backend
        generates a new primary key, inserts locally, then replicates according
        to your replication rules.
      </p>

      <div class="row">
        <strong>Central (node1)</strong>
      </div>
      <div class="row">
        <label>
          <input type="checkbox" id="centralInsertSimError" />
          Simulate replication error
        </label>
        <button onclick="insertOnNode('central')">Insert on central</button>
      </div>

      <div class="row" style="margin-top: 8px">
        <strong>Node2</strong>
      </div>
      <div class="row">
        <label>
          <input type="checkbox" id="node2InsertSimError" />
          Simulate replication error
        </label>
        <button onclick="insertOnNode('node2')">Insert on node2</button>
      </div>

      <div class="row" style="margin-top: 8px">
        <strong>Node3</strong>
      </div>
      <div class="row">
        <label>
          <input type="checkbox" id="node3InsertSimError" />
          Simulate replication error
        </label>
        <button onclick="insertOnNode('node3')">Insert on node3</button>
      </div>
    </fieldset>

    <fieldset>
      <legend>Custom Scripted Txn (using /txn/scripted)</legend>
      <p style="font-size: 12px; opacity: 0.8">
        Each script should be a JSON array of steps. Example:<br />
        <code>
          [ { "type": "READ" }, { "type": "SLEEP", "delayMs": 1000 }, { "type":
          "UPDATE", "data": { "city": "NewCity" } }, { "type": "READ" } ]
        </code>
      </p>

      <h4>Central node script (node1)</h4>
      <textarea id="script-central">
[
  { "type": "READ" },
  { "type": "SLEEP", "delayMs": 1000 },
  { "type": "UPDATE", "data": { "city": "CentralCity-" } },
  { "type": "READ" }
]</textarea
      >
      <div class="row">
        <label>
          <input type="checkbox" id="centralSimError" />
          Simulate replication error on central
        </label>
      </div>

      <h4>Node2 script</h4>
      <textarea id="script-node2">
[
  { "type": "READ" },
  { "type": "SLEEP", "delayMs": 500 },
  { "type": "UPDATE", "data": { "city": "Node2City-" } },
  { "type": "READ" }
]</textarea
      >
      <div class="row">
        <label>
          <input type="checkbox" id="node2SimError" />
          Simulate replication error on node2
        </label>
      </div>

      <h4>Node3 script (optional)</h4>
      <textarea id="script-node3">
[
  { "type": "READ" }
]</textarea
      >
      <div class="row">
        <label>
          <input type="checkbox" id="node3SimError" />
          Simulate replication error on node3
        </label>
      </div>

      <div style="margin-top: 8px">
        <button onclick="runScriptedAll()">Run scripted on all nodes</button>
      </div>
    </fieldset>

    <h3>Log</h3>
    <pre id="log"></pre>

    <script>
      // ðŸ”§ CONFIG: adjust these URLs to match your Docker/setup
      const NODES = {
        central: "http://localhost:3010", // central node (full copy)
        node2: "http://localhost:3011", // fragment
        node3: "http://localhost:3012", // fragment (if used),
      };

      const logEl = document.getElementById("log");

      function clearLog() {
        logEl.textContent = "";
      }

      function pretty(obj) {
        if (typeof obj === "string") return obj;
        try {
          return JSON.stringify(obj, null, 2);
        } catch {
          return String(obj);
        }
      }

      function log(msg, cssClass) {
        const now = new Date().toISOString();
        const line = `[${now}] ${msg}\n`;
        logEl.textContent += line;
      }

      function getUpdateFields() {
        const readField = (id) => {
          const v = document.getElementById(id).value;
          return v === "" ? undefined : v;
        };

        return {
          username: readField("username"),
          first_name: readField("first_name"),
          last_name: readField("last_name"),
          city: readField("city"),
          country: readField("country"),
          zipcode: readField("zipcode"),
          gender: readField("gender"),
        };
      }

      function getIsolation() {
        return document.getElementById("isolation").value;
      }

      function getUserId() {
        return Number(document.getElementById("userId").value);
      }

      async function postJson(url, body) {
        const res = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });

        const text = await res.text().catch(() => "");
        let parsed;
        try {
          parsed = JSON.parse(text);
        } catch {
          parsed = text;
        }
        return { status: res.status, body: parsed };
      }

      // ðŸ” Run recovery on all nodes sequentially
      async function runRecoveryAll() {
        log(
          "--- Running recovery on all nodes (central â†’ node2 â†’ node3) ---",
          "log-header"
        );

        const nodes = [
          { key: "central", url: NODES.central },
          { key: "node2", url: NODES.node2 },
          { key: "node3", url: NODES.node3 },
        ];

        for (const { key, url } of nodes) {
          log(`Calling ${key} /recovery/run`, "log-header");
          try {
            const res = await postJson(`${url}/recovery/run`, {});
            const cls =
              key === "central"
                ? "log-node-central"
                : key === "node2"
                ? "log-node-node2"
                : "log-node-node3";
            log(
              `${key} /recovery/run â†’ ${res.status}\n${pretty(res.body)}`,
              cls
            );
          } catch (e) {
            log(`${key} /recovery/run ERROR: ${e}`, "log-header");
          }
        }

        log("--- Recovery finished ---", "log-header");
      }

      // Simple insert with auto-id on any node
      async function insertOnNode(nodeKey) {
        const isolation = getIsolation();
        const fields = getUpdateFields();
        const simCheckboxId = `${nodeKey}InsertSimError`;
        const simReplicationError =
          document.getElementById(simCheckboxId)?.checked || false;

        const body = {
          isolation,
          simReplicationError,
          ...fields,
        };

        log(`${nodeKey} /txn/insert-auto â† ${pretty(body)}`, "log-header");

        const nodeUrl = nodeKey === "central" ? NODES.central : NODES[nodeKey];

        const res = await postJson(`${nodeUrl}/txn/insert-auto`, body);

        const cls =
          nodeKey === "central"
            ? "log-node-central"
            : nodeKey === "node2"
            ? "log-node-node2"
            : "log-node-node3";

        log(
          `${nodeKey} /txn/insert-auto â†’ ${res.status}\n${pretty(res.body)}`,
          cls
        );
      }

      // ðŸŸ¢ Case 1: all nodes do READ on same userId concurrently (using /txn/local)
      async function runCase1() {
        log(
          "--- Case 1: concurrent READs on central, node2, node3 ---",
          "log-header"
        );

        const isolation = getIsolation();
        const userId = getUserId();

        const body = {
          isolation,
          operation: "READ",
          userId,
        };

        log(
          `Sending READ to all nodes with isolation="${isolation}", userId=${userId}`
        );

        const [c, n2, n3] = await Promise.all([
          postJson(`${NODES.central}/txn/local`, body),
          postJson(`${NODES.node2}/txn/local`, body),
          postJson(`${NODES.node3}/txn/local`, body),
        ]);

        log(
          `central /txn/local â†’ ${c.status}\n${pretty(c.body)}`,
          "log-node-central"
        );
        log(
          `node2   /txn/local â†’ ${n2.status}\n${pretty(n2.body)}`,
          "log-node-node2"
        );
        log(
          `node3   /txn/local â†’ ${n3.status}\n${pretty(n3.body)}`,
          "log-node-node3"
        );
      }

      // ðŸŸ¡ Case 2: central does UPDATE while node2 does READ (using /txn/local)
      async function runCase2() {
        log(
          "--- Case 2: central UPDATE + node2 READ concurrently ---",
          "log-header"
        );

        const isolation = getIsolation();
        const userId = getUserId();
        const fields = getUpdateFields();

        const updateBody = {
          isolation,
          operation: "UPDATE",
          userId,
          ...fields,
        };

        const readBody = {
          isolation,
          operation: "READ",
          userId,
        };

        log(
          `central UPDATE + node2 READ, isolation="${isolation}", userId=${userId}, updateFields=${pretty(
            fields
          )}`
        );

        const [c, n2] = await Promise.all([
          postJson(`${NODES.central}/txn/local`, updateBody),
          postJson(`${NODES.node2}/txn/local`, readBody),
        ]);

        log(
          `central UPDATE â†’ ${c.status}\n${pretty(c.body)}`,
          "log-node-central"
        );
        log(
          `node2   READ   â†’ ${n2.status}\n${pretty(n2.body)}`,
          "log-node-node2"
        );
      }

      // ðŸ”´ Case 3: central + node2 do UPDATE concurrently (write-write)
      async function runCase3() {
        log(
          "--- Case 3: concurrent WRITEs on central + node2 ---",
          "log-header"
        );

        const isolation = getIsolation();
        const userId = getUserId();
        const fields = getUpdateFields();

        const bodyCentral = {
          isolation,
          operation: "UPDATE",
          userId,
          ...fields,
          city: `FromCentral-${Date.now()}`,
        };

        const bodyNode2 = {
          isolation,
          operation: "UPDATE",
          userId,
          ...fields,
          city: `FromNode2-${Date.now()}`,
        };

        log(
          `central + node2 both UPDATE userId=${userId} with different city values, isolation="${isolation}"`
        );

        const [c, n2] = await Promise.all([
          postJson(`${NODES.central}/txn/local`, bodyCentral),
          postJson(`${NODES.node2}/txn/local`, bodyNode2),
        ]);

        log(
          `central UPDATE â†’ ${c.status}\n${pretty(c.body)}`,
          "log-node-central"
        );
        log(
          `node2   UPDATE â†’ ${n2.status}\n${pretty(n2.body)}`,
          "log-node-node2"
        );

        // Read back final values to show convergence
        const readBody = {
          isolation,
          operation: "READ",
          userId,
        };

        const [cR, n2R] = await Promise.all([
          postJson(`${NODES.central}/txn/local`, readBody),
          postJson(`${NODES.node2}/txn/local`, readBody),
        ]);

        log("After concurrent WRITEs, final READs:", "log-header");
        log(
          `central READ â†’ ${cR.status}\n${pretty(cR.body)}`,
          "log-node-central"
        );
        log(
          `node2   READ â†’ ${n2R.status}\n${pretty(n2R.body)}`,
          "log-node-node2"
        );
      }

      // âš™ï¸ Scripted runner: calls /txn/scripted on any node that has a script
      async function runScriptedAll() {
        log(
          "--- Custom SCRIPTED txns on central / node2 / node3 ---",
          "log-header"
        );

        const isolation = getIsolation();
        const userId = getUserId();

        const scriptCentralText = document
          .getElementById("script-central")
          .value.trim();
        const scriptNode2Text = document
          .getElementById("script-node2")
          .value.trim();
        const scriptNode3Text = document
          .getElementById("script-node3")
          .value.trim();

        const centralSimError =
          document.getElementById("centralSimError").checked;
        const node2SimError = document.getElementById("node2SimError").checked;
        const node3SimError = document.getElementById("node3SimError").checked;

        const tasks = [];

        const parseSteps = (txt, label) => {
          if (!txt) return null;
          try {
            const parsed = JSON.parse(txt);
            if (!Array.isArray(parsed)) {
              log(
                `${label}: script must be a JSON array of steps`,
                "log-header"
              );
              return null;
            }
            return parsed;
          } catch (e) {
            log(`${label}: JSON parse error: ${e}`, "log-header");
            return null;
          }
        };

        const centralSteps = parseSteps(scriptCentralText, "central");
        const node2Steps = parseSteps(scriptNode2Text, "node2");
        const node3Steps = parseSteps(scriptNode3Text, "node3");

        if (centralSteps) {
          const body = {
            isolation,
            userId,
            steps: centralSteps,
            simReplicationError: centralSimError,
          };
          tasks.push(
            postJson(`${NODES.central}/txn/scripted`, body).then((res) => ({
              node: "central",
              res,
            }))
          );
        }

        if (node2Steps) {
          const body = {
            isolation,
            userId,
            steps: node2Steps,
            simReplicationError: node2SimError,
          };
          tasks.push(
            postJson(`${NODES.node2}/txn/scripted`, body).then((res) => ({
              node: "node2",
              res,
            }))
          );
        }

        if (node3Steps) {
          const body = {
            isolation,
            userId,
            steps: node3Steps,
            simReplicationError: node3SimError,
          };
          tasks.push(
            postJson(`${NODES.node3}/txn/scripted`, body).then((res) => ({
              node: "node3",
              res,
            }))
          );
        }

        if (tasks.length === 0) {
          log("No valid scripts to run.", "log-header");
          return;
        }

        const results = await Promise.all(tasks);

        for (const { node, res } of results) {
          const cls =
            node === "central"
              ? "log-node-central"
              : node === "node2"
              ? "log-node-node2"
              : "log-node-node3";
          log(
            `${node} /txn/scripted â†’ ${res.status}\n${pretty(res.body)}`,
            cls
          );
        }
      }
    </script>
  </body>
</html>
